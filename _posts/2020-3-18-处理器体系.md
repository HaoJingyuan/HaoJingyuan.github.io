## 换个角度看硬件
### ISA 
指令集体系结构，指的是处理器支持的指令和字节级编码，定义机器级程序的格式和行为，定义处理器的状态，指令的格式，指令对状态的影响。

### Y86-64指令集体系结构
包括四部分：状态单元，指令集和它们的编码，一组编程规范，异常事件处理

#### 可见状态
1. 程序寄存器
2. 条件码
3. PC
4. 内存
5. 程序状态

#### 指令
- movq
- addq,subq,andq,xorq
- jmp,jle,jl,je,jne,jge,jg
- cmov
- call ret
- pushq popq
- halt

#### 编码
15个程序寄存器每个都有一个在0到0XE之间的寄存器标识符，这个标识符就是寄存器的地址。寄存器存在CPU中的寄存器文件中，这个文件是个小的随机访问存储器</br>
CISC 复杂指令集，RISC 精简指令集

### 逻辑设计与硬件控制语言HCL
数字系统需要的三部分：计算的组合逻辑，存储位的存储单元，控制存储单元更新的时钟信号

#### 逻辑门
HCL && || ！

#### 组合电路
位级：检测位相等，单个位的多路复用 </br>
字级：字级相等检测，HCL允许比较指定位数的两个字 A==B。字级多路复用，用情况表达式描述
ALU：算术逻辑单元，输入：两个操作数，一个控制，控制值对应不同功能码

#### 集合关系
将一个信号与许多信号做比较。

#### 存储器和时钟
时序电路要求保存状态，必须引入存储设备。
1. 时钟寄存器，存储单个字或位，时钟控制寄存器加载输入值。如PC,条件代码，程序状态
2. 随机访问寄存器，即内存，存储多个字，需要地址信息来决定读写什么值。如寄存器文件。虚拟内存

硬件寄存器，在时钟信号发生跳变，才会更新输出值。</br>
寄存器文件有读写控制，地址，数据输入，时钟输入，数据输出。还有一个只读存储器，用来读取指令。一般这两个存储器会被合并为一个具有双端口的存储器，
一个用来读指令，一个用来读写数据。各个寄存器的地址就是他们的ID。

### 顺序实现
每个时钟周期上，SEQ执行处理一条指令所需的全部步骤。因此，时钟频率会很低很低。

#### 分阶段
所有指令执行都被分成相同的阶段，下一步是哪个阶段取决于正在执行的指令。
- 阶段
1. 取指：根据PC中的值，到对应内存中去取指令字节，寄存器ID，立即数。计算下一条指令的地址，计算方法:当前PC+取出来指令的长度
2. 译码：从寄存器文件中读入最多两个操作数。有可能是读入指令指明的寄存器，也可能是rsp栈指针寄存器
3. 执行：ALU执行计算功能，算加减乘除或基址偏移；栈指针增加或减少；检查条件。得到的值称作valE。
4. 访存：将数据写入内存；从内存中读出数据，读出的值叫valM。
5. 写回：最多将两个结果写回到寄存器文件
6. 更新PC： 将PC更新为下一条指令的地址
- 时序控制
1. PC装载新的地址：每个时钟周期
2. 条件码寄存器装载新的值：整数运算指令时
3. 写数据内存：rmmovq,pushq,call
4. 寄存器文件：写端口允许每个周期更新两个寄存器

### 流水线
- 通用原理
待执行的任务被划分为多个阶段，多个顾客可以同时经过系统，经过的速度一样。提高了吞吐量-单位时间处理任务的数量，但也增加了延迟，服务某些顾客的时间边长了。

#### 计算流水线
- 吞吐量
    - 含义：一秒多少条指令。指令单位：GIPS千兆条。吞吐量为3GIPS就是说一秒执行3千兆条指令。GIPS= 10^12 条/秒
    - 公式：吞吐量（GIPS） = 1 / 一个周期指令执行时间（ps）
- 非流水线转为流水线
    - 方式：组合逻辑拆分，添加流水线寄存器
    - 吞吐量增加，延迟增加

#### 操作说明
- 流水线阶段之间的指令转移是由时钟信号来控制的
- 时钟到达后，前一阶段的输出加载到流水线寄存器中，作为下一阶段的输入
- 减缓时钟不会影响流水线的行为。加快时钟时，如果时钟太快以至于组合逻辑不能得出正确的值，就会导致流水线行为异常

#### 局限性
哪些因素会降低流水线的效率？
1. 不一致的划分
    由于时钟的最低频率是由最慢的阶段所限制的，而阶段划分一般不一致，就导致流水线吞吐量下降，延迟增加
2. 流水线过深
    流水线过深意味着引入的流水线寄存器个数越多，增加的延迟越多。最小时钟周期越短，寄存器导致的延迟所占比重越大。此时，延迟成了制约因素
    
#### 带反馈的流水线
1. 数据相关
    指令间用到了相同的数据，在流水线中，有可能上一条还没得出结果，但下一条就要用这个结果
2. 控制相关
    SEQ中，控制相关通过反馈解决，但在流水线中，直接的反馈会导致改变系统的行为

#### 预测下一个PC
- 原因：流水线要求每个周期发射一条新的指令，因此需要在取出当前指令后马上确定下一条指令的地址
- 做法：

| 指令 | 正确预测方法 | 实际预测方法 |
| --- | --- | --- |
| 条件分支指令 | 几个周期后，执行阶段结束得出cnd | 分支预测技术，valC与valP中选一个 |
| ret | 访存阶段后得到valM | 1.暂停等valM 2.使用栈，利用调用与返回成对出现的性质 |
| call jmp | 直接得到valC | 同前  |
| 其他指令 | 直接得到valP | 同前 |
#### 流水线冒险
- 数据冒险
  类型：读操作数时写还未完成</br>
  避免冒险的方法：</br>
      1.暂停：降低了吞吐量
      2.转发：发现要读的值还没被写，直接拿要写的那个数
      
  | 阶段 | 值 |
  | --- | --- |
  |E--D|e-valE|
  |M--D|m_valM,M_valE|
  |W--D|W_valM,w_valE|
  
     3.转发不能处理的情况：加载/使用数据类型的冒险
        要求M--D，但D在M前，需要暂停，称为加载互锁。
- 控制冒险
  ret：等ret W阶段结束
  预测错误：插入气泡，取出跳转指令后面的指令

#### 异常处理
 - 报告流水线中最深的指令引起的异常：第一条引起异常的指令会第一个结束。
 - 分支预测错误导致取消了异常指令：每个流水线寄存器设置状态码stat，沿着流水线传播，在写回阶段发现异常再停止。被取消的指令，异常也被取消了。
 - 异常指令后面的指令修改了系统状态：如果由于指令在访存或写回阶段发生异常，那么禁止更新条件码寄存器或数据内存。
 

#### 各阶段实现
- 取指阶段F

|  |  |
| --- | --- |
|PC来源 | 预测错误M_valA，ret返回W_valM,其他  |
|其他 | valP,CALL产生的f_valC |

- 译码和写回阶段 D W
  转发控制模块，根据输入寄存器ID与EWM来的寄存器ID比较，相同就转发对应数据作为valA或valB。转发优先级EMW
- 执行阶段 E
  e_valE作为计算出的结果，e_desE作为要写的寄存器地址，传回译码阶段。SetCC由W_stat，m_stat作为输入，作用是异常发生时禁止更新条件码。
- 访存阶段 M
  
  






