# 你了解计算机里面的信息吗？

## 寻址和字节顺序
## 字符串
如何理解字符串？
一个个的字符+null

因为字符是一字节，所以字符串的ASCII码表示与字节顺序，字节大小规则无关。得出结论：` 文本数据比二进制数据有更强的平台独立性 `
## 代码
不同机器类型（Linux32.Linux64，Windows，Sun）使用不同的且不兼容的指令和编码方式。即使完全一样的进程在不同操作系统上会产生不同的编码。得出结论:`二进制代码
是不兼容的 `
## 布尔代数
位向量运算：按位与，按位或 ，按位异或
```c
  a & b;
  a | b;
  a ^ b;
```
位向量十分十分有用的应用：
- **表示有限集合**
1. 每个位代表集合中对应元素的存在与否。实际应用有:屏蔽中断信号，在处理大量数据的算法中也很有用
- **掩码运算**: 
1. x & 0XFF，0XFF称作掩码，会选出x的低八位。
2. ~0 会得到全1的掩码，不管机器的字大小是多少
  
## 逻辑运算
逻辑运算符 **&&** **||** **！**
不要与位级运算混淆，逻辑运算中非0为TRUE,0为FALSE。运算结果只有两种。

## 移位运算
左   移：低位补0</br>
算数右移：左端补k个最高有效位的值，针对有符号数，防止移位后补0导致变号</br>
逻辑右移：高位补0</br>
注意事项：
1. 移动位数k > 待移位值w 时，C语言中会只考虑k的低log2w位。标准做法：移位前 k mod w
2. 优先级问题：四则运算高于移位

## 整数表示
用位来编码两种不同的整数
### 无符号数编码
假设有w位，每一位都代表二进制数。无符号数编码具有唯一性
### 补码编码
  - 最高位称为符号位，解释为负权。计算时符号位加负号，所以被解释为负权。
  - 补码编码具有唯一性
  - 几乎所有机器都用补码表示有符号整数。比如-12345在大端机器里就是0Xcfc7,1100111111000111.
  - 获取一个数的补码两种方式：
  1. 自己用原码算。除了符号位，别的位取反，再+1.
  2. 输入计算机中，获取16进制表示的字节，按照大小端机器排列，得到的就是补码。
  - 补码的特点：
  1. 范围不对称。原因：n位补码，能表示的数量是偶数（2^n）,其中一半是负数，另一半是非负数。非负数中有个0，所以负数比正数多一个。
  2. -1的补码与相同位数的无符号数的最大值有相同的位表示。都是全为1的串。
### 有符号数与无符号数的转换
转换原则:计算机中存放的二进制数不变，改变了解释这些二进制数的规则。
C语言中，执行一个运算时，如果一个是有符号，一个无符号。都当无符号。普通算数运算没有差异，但执行<,>这样的关系运算符会出错。
```c
-1 < 0u;  //false  -1被当做无符号数，=Umax
```
Tmin不能写成0X80000000或-2147483648，要写成 -2147483767-1
### 如何扩展一个数字的位表示
无符号数：零扩展，在开头加0
补码：符号扩展，在开头加符号位
```c
//大端机器
short sx = -12345; // cf c7
int x = sx;        // ff ff cf c7
unsigned short usx = sx;     // usx=53191  cf c7
unsigned int ux = usx;       // usx=53191  00 00 cf c7
```
### 截断数字
截断数字会丢弃高位的数字。剩下的数字按照无符号数，补码对应的规则解释。
### 关于有符号数无符号数的建议
```c
float sum(float a[],unsigned int length)
{
int i = 0;
float result = 0;
for(;i <= length -1;i++)    //正确：i < length
{
  sum += a[i];
}
return result;
}
```
长度是unsigned，大于0，没有问题。问题在于函数体内用 无符号数length与1进行相减，相当于 length + 0xffff（假设32位机器）
当length >= 1 时 length + 0xff - (0xffff + 1) = length - 1,没有问题</br>
当length = 0 时，length + 0xff < 0xff +1,所以结果就是 0xff，无论i怎么加都不会大于0xff，导致内存出错</br>
```c
int strlonger(char*s,char*t)
{
  return strlen(s) - strlen(t) > 0;
}
```
两个无符号数相减，如果减不过，不会出现负数，会出现大正数。直接比较二者大小即可。
```c
int copy_from_kernal(void *user_dest,int maxlen)
{
  int len = KSIZE < maxlen ? KSIZE : maxsize; //KSIZE=1024
  memcpy(user_dest,kernal_buf,len);
  return len;
}
```
一般len大于0，如果有人恶意输入负值，会导致len也是负值，memcpy原型输入参数是unsigned，那么会拷贝一块很大的内存出来。
- 建议：
1. 无符号数不要相减；也不要和有符号数减，减出负数就是灾难。
2. 函数传递无符号数一定要检查每一个子函数的参数，有符号的负数被转为无符号就是灾难。
### 整数运算
- 无符号加法：假设二进制表示共有w位。溢出后的结果是：求和后减2^w
- 无符号求反：不为0时，求反 = 2^w - 原数
- 补码加法：机器运算原理：符号位会参与运算，算完后把高于w位的截断。正溢出时结果-2^w,负溢出+2^w。所以两个大正数加出来是负数，大负数加出来是正数。
- 补码的非：每一位取反再加1.tmin的反==tmin 其余的反就是加负号
## 浮点数表示
  - 定点表示法：小数点后代表1/2,1/4···
  - IEEE浮点表示：
    - $$V=(-1)^s\timesM\times2^E$$
    - 符号：s；阶码：E；尾数：M
      以单精度为例：s占1位，E占8位，M占23位.根据exp的值，被编码的值可以分成三种不同情况
      1. 规格化的值。
      E = exp - bias，bias = 2^(k-1)-1   即2^7-1 = 127</br>
      M = 1 + f,f = 后面23位的值。</br>
      最终得到  一点几 乘 2的（-126到127）次方
      2. 非规格化的值：阶码全为0
      E = 1 - bias，M = f
      当M == 0 时，该浮点数就是0
      当M ！= 0 时，表示十分接近0的数
      3. 特殊值：阶码全为1
      f = 0 浮点数 = 无穷，f ！= 0 浮点数 = NaN
  - 几个重要的浮点数
    | 描述 | exp | frac | IEEE表示 | 十进制值 |
    | --- | --- | --- | --- | --- |
    |0|全0|全0|0|0|
    |最小非规格化数|全0|1| 2^(-23) * 2^(-126)|1.4 * 10^(-45)|
    |1|除首位全1，即2^(k-1)|全0|1 * 2^(0)|1.0|
    |最大规格数|全1-1，即末位为0|全1|(2-\epsilon) * 2^127|3.4 * 10^38|
  - 舍入
    常使用向偶数舍入，即取数轴上离自己近的那一个数
  - 计算
    缺少结合性和分配性 3.14+1e10-le10 = 0;3.14+(1e10 - 1e10) = 3.14;
    
