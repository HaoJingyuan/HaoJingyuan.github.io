# 你了解计算机里面的信息吗？

## 寻址和字节顺序
## 字符串
如何理解字符串？
一个个的字符+null

因为字符是一字节，所以字符串的ASCII码表示与字节顺序，字节大小规则无关。得出结论：` 文本数据比二进制数据有更强的平台独立性 `
## 代码
不同机器类型（Linux32.Linux64，Windows，Sun）使用不同的且不兼容的指令和编码方式。即使完全一样的进程在不同操作系统上会产生不同的编码。得出结论:`二进制代码
是不兼容的 `
## 布尔代数
位向量运算：按位与，按位或 ，按位异或
```c
  a & b;
  a | b;
  a ^ b;
```
位向量十分十分有用的应用：
- **表示有限集合**
1. 每个位代表集合中对应元素的存在与否。实际应用有:屏蔽中断信号，在处理大量数据的算法中也很有用
- **掩码运算**: 
1. x & 0XFF，0XFF称作掩码，会选出x的低八位。
2. ~0 会得到全1的掩码，不管机器的字大小是多少
  
## 逻辑运算
逻辑运算符 **&&** **||** **！**
不要与位级运算混淆，逻辑运算中非0为TRUE,0为FALSE。运算结果只有两种。

## 移位运算
左   移：低位补0</br>
算数右移：左端补k个最高有效位的值，针对有符号数，防止移位后补0导致变号</br>
逻辑右移：高位补0</br>
注意事项：
1. 移动位数k > 待移位值w 时，C语言中会只考虑k的低log2w位。标准做法：移位前 k mod w
2. 优先级问题：四则运算高于移位

## 整数表示
用位来编码两种不同的整数
### 无符号数编码
假设有w位，每一位都代表二进制数。无符号数编码具有唯一性
### 补码编码
  - 最高位称为符号位，解释为负权。计算时符号位加负号，所以被解释为负权。
  - 补码编码具有唯一性
  - 几乎所有机器都用补码表示有符号整数。比如-12345在大端机器里就是0Xcfc7,1100111111000111.
  - 获取一个数的补码两种方式：
  1. 自己用原码算。除了符号位，别的位取反，再+1.
  2. 输入计算机中，获取16进制表示的字节，按照大小端机器排列，得到的就是补码。
  - 补码的特点：
  1. 范围不对称。原因：n位补码，能表示的数量是偶数（2^n）,其中一半是负数，另一半是非负数。非负数中有个0，所以负数比正数多一个。
  2. -1的补码与相同位数的无符号数的最大值有相同的位表示。都是全为1的串。
### 有符号数与无符号数的转换
转换原则:计算机中存放的二进制数不变，改变了解释这些二进制数的规则。
C语言中，执行一个运算时，如果一个是有符号，一个无符号。都当无符号。普通算数运算没有差异，但执行<,>这样的关系运算符会出错。
```c
-1 < 0u;  //false  -1被当做无符号数，=Umax
```
Tmin不能写成0X80000000或-2147483648，要写成 -2147483767-1
### 如何扩展一个数字的位表示
无符号数：零扩展，在开头加0
补码：符号扩展，在开头加符号位
```c
//大端机器
short sx = -12345; // cf c7
int x = sx;        // ff ff cf c7
unsigned short usx = sx;     // usx=53191  cf c7
unsigned int ux = usx;       // usx=53191  00 00 cf c7
```
