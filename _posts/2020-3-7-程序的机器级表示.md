# 你了解机器的语言吗

## 动机
- 分析代码中隐含的低效率
- 深入了解程序运行时的行为，高级语言的抽象会隐藏一些信息
## 程序编码
- 过程：
1. 预处理器扩展源代码
2. 编译器产生汇编文件
3. 汇编器产生目标文件
4. 链接器合并目标文件与库
### 机器级代码
- 两种抽象：
1. ISA 指令集架构/指令集体系结构
定义机器级程序的格式和行为，定义处理器的状态，指令的格式，指令对状态的影响。指令看起来是顺序执行的，实际处理器硬件可以并发执行许多指令。
2. 机器级程序使用的地址是虚拟地址。
- 机器代码多包含的信息
1. 程序计数器，PC，x86中用%rip表示。含义：将要执行的下一条指令在内存中的地址
2. 寄存器文件  16个命名的位置，每个存储64位的值。 作用：存放地址，整数，重要状态，临时数据
3. 条件码寄存器 作用：控制数据流的条件变化
4. 向量寄存器 作用：存放整数或浮点数
机器代码中不区分数据类型，把内存看做一个很大的，按**字节**寻址的数组(地址加1代表指向下一个字节)。操作系统管理虚拟地址，将其翻译成处理器内存中的物理地址。
### 代码含义
  每条指令会被翻译成指定的字节值。例如：push指令就是 0x53.指令长度1~15字节不等。反汇编器根据机器代码确定汇编代码。
### 如何看编译器生成的.s文件
- 以.开头的是指导汇编器和链接器工作的伪指令
## 数据格式
字表示16bit，所以32叫双字，64位四字。指针和long，double是四字。</br>
movb 表示传送字节。浮点数使用完全不同的指令，所以后缀 l 不会引起歧义
|c声明|汇编代码后缀|
|---|---|
|char|b byte|
|short|w word|
|int|l double word|
|long|q quad words|
|char *|q|
|float|s|
|double|l|

## 如何访问信息
- CPU 包含一组通用目的寄存器，由16个存储64bits的寄存器构成。用来存放指针和整数。</br>
- 名称：%rax~%rdx,%rsi,%rdi,%r8~%r15.特殊的%rsp，存放栈指针。</br>
- 不同指令可以操作不同字节数，4字节指令会把高四字节置0、1、2字节指令保持高位不变。
- 寄存器大小演化与名称

| 8位机 | 8086 | IA32 | X86-64 |
| --- | --- | --- | --- |
| a1 | ax | eax | rax |

### 操作数指示符
- 三种操作数
1. 立即数。表示常数值。$数字
2. 寄存器。表示某个寄存器内的内容。用r_{a}表示寄存器，R[r_{a}]表示它的值
3. 内存引用。根据算出来的地址（称作有效地址）访问某个内存位置。M_{b}[Addr],表示从Addr开始的b个字节
### 数据传送指令
MOV S D 把数据从源位置S复制到目的位置D。不能把数从内存复制到内存。
当源数据大小较小，目的较大时 **源数据**为无符号数用MOVZ，高位补0，目的为补码数用MOVS，高位补符号位。
假设源数据地址存在%rdi中，目的地址存在%rsi中
|源数据|目的数据|指令|解释|
|---|---|---|---|
|char|int|MOVSBL (%rdi),%eax   MOVl %eax,(%rsi)|有符号，短变长|
|char|unsigned|MOVZBL (%rdi),%rax  MOVl %rax,(%rsi)|先补0，保证变过去是无符号|
|unsigned char|long|MOVZBQ MOVQ|补0，保证和原来码一样|
|int|char|MOVL MOVB|读4字节，存1字节|
|unsigned int|unsigned char|MOVL  MOVB|读4字节，存1字节|
|char|short|MOVSBW  MOVW|读一字节扩展符号位，存2字节|
### 实例
```c
long exchange(long *xp,long y)
{
    long x = *xp;
    *xp = y;
    return x;
}

exchange:
    movq (%rdi),%rax    根据寄存器rdi中的值xp，取到内存中的值。再复制到rax寄存器
    movq %rsi,(%rdi)    把rsi寄存器中的值(y)复制到 rdi寄存器中的xp指向的内存
    ret
```
指针就是地址，解引用指针就是存储器间接寻址的过程。像x这样的局部变量，存在寄存器中，访问很快。
### 入栈出栈数据
- 程序栈在内存中的某个区域
- 栈**向下生长**。因此栈顶地址最小，按照惯例画图的时候栈底放上面。
- %rsp保存着栈顶元素的地址
- 命令：
1. pushq S   找到栈顶元素地址并计算新的栈顶元素地址(新地址 = 旧地址 - 8)，再把数据复制到对应内存中。但pushq命令被编码为1字节
2. popq D 从内存中找到栈顶元素的值，返回给rax寄存器，rsp寄存器 + 8。出栈操作并不会把出栈元素删除，只是改变了栈顶指针。
## 算数和逻辑操作
分为四类，分别是加载有效地址，一元操作，二元操作，移位。除了加载有效地址leaq，别的都有大小操作数之分。
### 加载有效地址
load effective address指令 leaq 是movq的变形。指令形式：leaq S,D.通常用来执行一些简单的算术运算。
- 含义：把S中的东西运到D中
- 举例：leaq 7(%rdx,%rdx,4),%rax。假设rdx中的值为1.，则该指令执行 rax中的值 = 7\*(1+1\*4).相当于做了一次算术运算。
- 操作数S看起来像取内存中的值，实际上不是。只是计算了内存地址再赋值给D。D只能是寄存器。
### 一元和二元操作符
- 一元操作：只有一个操作数，既是源又是目的，可以是寄存器，也可以是内存位置。
- 指令：INC DEC NEG取负 NOT取补
- 二元操作：第一个操作数可以是立即数，寄存器或内存位置。第二个操作数，既是源又是目的，可以是寄存器或内存位置。
- 指令：ADD SUB IMUL乘 XOR异或 OR或 AND与
- 举例：subq %rax,%rdx   即 rdx = rdx - rax
### 移位操作
- 先给出移位量。可以是立即数，也可以是单字节寄存器 %c1 中的数。%c1中的移位量由低m位决定，m由操作指令决定。
- 指令：SAL左移 SHL左移 SAR算术右移（补符号位） SHR逻辑右移（补0） 
- 举例：salb %c1,0x13  b是8位，2的三次==8，所以看%c1的低三位是几，就左移几位。
## 控制
### 条件码
CPU除了整数寄存器，还维护了一组单个位的条件码寄存器，描述最近的算术或逻辑的属性。通过检测这些寄存器来执行条件分支指令
- 具体指令：
1. CF:进位标志。检查无符号操作的溢出
2. ZF：零标志。检查最近得出的结果为0
3. SF：符号标志：最近的操作得到的结果为负数
4. OF：溢出标志，补码的溢出
除了leaq 别的指令都可以改变条件码。
CMP S1,S2  S2-21  TEST S1,S2 S1 & S2只改变条件码，不改变目的寄存器的值
### 访问条件码
通常不会直接读取，使用的三种方式：
1. 根据条件码的组合，将一个字节设置为1或0
- SET指令，后缀表示不同的条件。目的操作数是低位单字节寄存器，或一字节大小的内存。总之，就8位。
- 有符号数 根据溢出位OF和负数位SF判断大小SETG(greater)，SETL(less)，无符号数根据ZF和进位标志CF SETA(above),SETB(below)。
2. 条件跳转到程序的其他部分
3. 有条件地传送数据
### 跳转指令
- 指令：jmp 跳转目的。 
1. 直接跳转：给出标号作为跳转目标   jmp .L1
2. 间接跳转： 操作数指示符  例如 jmp \*%rax  jmp \*(%rax)
- 跳转指令的编码
1. PC相对的：目标地址编码 = 目标指令地址 - 紧跟在jmp命令后的指令地址 可以是1.2.4字节
2. 绝对编码：4个字节直接指定。
汇编器和链接器会选择适当的方式进行编码
### 条件控制实现条件分支
会为真假情况产生各自的代码块。根据cmp结果跳转到对应代码块。
### 条件传送实现天剑分支
计算两种情况的结果，根据条件选择其中一个结果。</br>
```c
cmpg %rsi,%rdi          //compare x,y
cmovge %rdx,%rax        //if >= 结果1 = 结果2
```
- 为什么条件传送比条件控制性能好？
流水线的设计使得需要知道后续的指令是什么。而条件控制必须在执行完后才能确定后面的指令。如果处理器预测错误，已经被装载的命令会被全部丢弃。
- GCC使用条件控制多一些，因为复杂计算的开销会更大。有些程序必须使用条件控制结构。

### 循环
- do whie结构，翻译为在循环块结尾判断是否执行条件跳转
- while，翻译为跳转到中间，执行一个无条件跳转到循环结尾测试

### switch语句
- 原理：
使用跳转表，表项i是代码段的地址，程序代码用开关索引值执行跳转表内的数组引用，确定跳转指令的目的地址。
当开关数量比较多，值的范围跨度比较小，会使用跳转表。
- 关键指令：jmp \*.L4(,%rsi,8) 
间接跳转，操作数在制定内存，索引由%rsi给出。跳转表对同样的情况使用相同的变号，未定义的使用默认的标号。

## 过程
过程是一种抽象，用一组参数和一个返回值实现某种功能。不同编程语言中，表项形式多样：函数、方法、子例程、处理函数等等。</br>
假设过程Q调用过程Q,Q执行后返回P。所包括的机制：
1. 传递控制，进入Q的时候，程序计数器必须设置成Q的代码的起始地址，返回后，PC要被设置成调用Q后面的那条语句的地址。
2. 传递数据，P向Q提供一个或多个参数，Q必须向P返回一个值
3. 分配和释放内存，开始前，Q可能需要为局部变量分配空间，返回前又必须要释放这些空间。

### 运行时栈
1. 使用栈实现后进先出的内存管理原则。栈和程序寄存器存放传递控制和数据，分配内存所需要的信息。栈向低地址生长，通过减小栈顶地址实现分配空间，
通过增大栈顶指针地址来释放空间。
2. 栈帧：当过程需要的存储空间 > 寄存器能够存放的大小，就会在栈上分配空间。这个部分称为过程的栈帧。大多数栈帧大小是固定的。
3. P调用Q，会把返回地址存到栈中，算作P的栈帧的一部分。Q可以在栈中保存寄存器的值，分配局部变量，设置参数。

### 转移控制
- 将控制从P转移到Q，只需要将PC指向Q的代码的起始地址即可。
- 指令：call Q,把地址A压入栈中，将PC设置为Q的起始地址。</br>
        ret 从栈中弹出A，将PC设置为A
### 数据传送
- 大部分数据传送通过寄存器实现，最多传递6个整型参数，，使用寄存器的名字取决于数据大小
- rdi,rsi,rdx,rcx,r8,r9以及对应的小字节名字
- 超过6个参数的部分需要通过栈传递。这些参数在栈中必须和8的倍数对齐
