# 你了解机器的语言吗
## 动机
- 分析代码中隐含的低效率
- 深入了解程序运行时的行为，高级语言的抽象会隐藏一些信息
## 程序编码
- 过程：
1. 预处理器扩展源代码
2. 编译器产生汇编文件
3. 汇编器产生目标文件
4. 链接器合并目标文件与库
### 机器级代码
- 两种抽象：
1. ISA 指令集架构/指令集体系结构
定义机器级程序的格式和行为，定义处理器的状态，指令的格式，指令对状态的影响。指令看起来是顺序执行的，实际处理器硬件可以并发执行许多指令。
2. 机器级程序使用的地址是虚拟地址。
- 机器代码多包含的信息
1. 程序计数器，PC，x86中用%rip表示。含义：将要执行的下一条指令在内存中的地址
2. 寄存器文件  16个命名的位置，每个存储64位的值。 作用：存放地址，整数，重要状态，临时数据
3. 条件码寄存器 作用：控制数据流的条件变化
4. 向量寄存器 作用：存放整数或浮点数
机器代码中不区分数据类型，把内存看做一个很大的，按**字节**寻址的数组(地址加1代表指向下一个字节)。操作系统管理虚拟地址，将其翻译成处理器内存中的物理地址。
### 代码含义
  每条指令会被翻译成指定的字节值。例如：push指令就是 0x53.指令长度1~15字节不等。反汇编器根据机器代码确定汇编代码。
### 如何看编译器生成的.s文件
- 以.开头的是指导汇编器和链接器工作的伪指令
## 数据格式
字表示16bit，所以32叫双字，64位四字。指针和long，double是四字。</br>
movb 表示传送字节。浮点数使用完全不同的指令，所以后缀 l 不会引起歧义
|c声明|汇编代码后缀|
|---|---|
|char|b byte|
|short|w word|
|int|l double word|
|long|q quad words|
|char *|q|
|float|s|
|double|l|

## 如何访问信息
- CPU 包含一组通用目的寄存器，由16个存储64bits的寄存器构成。用来存放指针和整数。</br>
- 名称：%rax~%rdx,%rsi,%rdi,%r8~%r15.特殊的%rsp，存放栈指针。</br>
- 不同指令可以操作不同字节数，4字节指令会把高四字节置0、1、2字节指令保持高位不变。
- 寄存器大小演化与名称

| 8位机 | 8086 | IA32 | X86-64 |
| --- | --- | --- | --- |
| a1 | ax | eax | rax |

### 操作数指示符
- 三种操作数
1. 立即数。表示常数值。$数字
2. 寄存器。表示某个寄存器内的内容。用r_{a}表示寄存器，R[r_{a}]表示它的值
3. 内存引用。根据算出来的地址（称作有效地址）访问某个内存位置。M_{b}[Addr],表示从Addr开始的b个字节
### 数据传送指令
MOV S D 把数据从源位置S复制到目的位置D。不能把数从内存复制到内存。
当源数据大小较小，目的较大时 **源数据**为无符号数用MOVZ，高位补0，目的为补码数用MOVS，高位补符号位。
假设源数据地址存在%rdi中，目的地址存在%rsi中
|源数据|目的数据|指令|解释|
|---|---|---|---|
|char|int|MOVSBL (%rdi),%eax   MOVl %eax,(%rsi)|有符号，短变长|
|char|unsigned|MOVZBL (%rdi),%rax  MOVl %rax,(%rsi)|先补0，保证变过去是无符号|
|unsigned char|long|MOVZBQ MOVQ|补0，保证和原来码一样|
|int|char|MOVL MOVB|读4字节，存1字节|
|unsigned int|unsigned char|MOVL  MOVB|读4字节，存1字节|
|char|short|MOVSBW  MOVW|读一字节扩展符号位，存2字节|
### 实例
```c
long exchange(long *xp,long y)
{
    long x = *xp;
    *xp = y;
    return x;
}

exchange:
    movq (%rdi),%rax    根据寄存器rdi中的值xp，取到内存中的值。再复制到rax寄存器
    movq %rsi,(%rdi)    把rsi寄存器中的值(y)复制到 rdi寄存器中的xp指向的内存
    ret
```
指针就是地址，解引用指针就是存储器间接寻址的过程。像x这样的局部变量，存在寄存器中，访问很快。
### 入栈出栈数据
- 程序栈在内存中的某个区域
- 栈**向下生长**。因此栈顶地址最小，按照惯例画图的时候栈底放上面。
- %rsp保存着栈顶元素的地址
- 命令：
1. pushq S   找到栈顶元素地址并计算新的栈顶元素地址(新地址 = 旧地址 - 8)，再把数据复制到对应内存中。但pushq命令被编码为1字节
2. popq D 从内存中找到栈顶元素的值，返回给rax寄存器，rsp寄存器 + 8。出栈操作并不会把出栈元素删除，只是改变了栈顶指针。
## 算数和逻辑操作
分为四类，分别是加载有效地址，一元操作，二元操作，移位。除了加载有效地址leaq，别的都有大小操作数之分。
### 加载有效地址
load effective address指令 leaq 是movq的变形。指令形式：leaq S,D.通常用来执行一些简单的算术运算。
- 含义：把S中的东西运到D中
- 举例：leaq 7(%rdx,%rdx,4),%rax。假设rdx中的值为1.，则该指令执行 rax中的值 = 7\*(1+1\*4).相当于做了一次算术运算。
- 操作数S看起来像取内存中的值，实际上不是。只是计算了内存地址再赋值给D。D只能是寄存器。
### 一元和二元操作符
- 一元操作：只有一个操作数，既是源又是目的，可以是寄存器，也可以是内存位置。
- 指令：INC DEC NEG取负 NOT取补
- 二元操作：第一个操作数可以是立即数，寄存器或内存位置。第二个操作数，既是源又是目的，可以是寄存器或内存位置。
- 指令：ADD SUB IMUL乘 XOR异或 OR或 AND与
- 举例：subq %rax,%rdx   即 rdx = rdx - rax
### 移位操作
- 先给出移位量。可以是立即数，也可以是单字节寄存器 %c1 中的数。%c1中的移位量由低m位决定，m由操作指令决定。
- 指令：SAL左移 SHL左移 SAR算术右移（补符号位） SHR逻辑右移（补0） 
- 举例：salb %c1,0x13  b是8位，2的三次==8，所以看%c1的低三位是几，就左移几位。
## 控制
### 条件码
CPU除了整数寄存器，还维护了一组单个位的条件码寄存器，描述最近的算术或逻辑的属性。通过检测这些寄存器来执行条件分支指令
- 具体指令：
1. CF:进位标志。检查无符号操作的溢出
2. ZF：零标志。检查最近得出的结果为0
3. SF：符号标志：最近的操作得到的结果为负数
4. OF：溢出标志，补码的溢出
除了leaq 别的指令都可以改变条件码。
CMP S1,S2  S2-21  TEST S1,S2 S1 & S2只改变条件码，不改变目的寄存器的值
