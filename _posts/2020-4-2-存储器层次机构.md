# 为什么不用硬盘代替内存条？

## 初识存储器层次
要有一个概念，CPU访问不同层次的存储器需要的时间不同。访问CPU寄存器，需要0个周期；访问高速缓存，需要4~75个周期；访问主存，
需要上百个周期；访问磁盘，需要几千万个周期。那么不同层次是如何组织的呢？

## 先来了解一下各种存储设备吧
### 随机访问存储器
常说的内存条就是随机访问存储器的一种。总体上分为两类：静态RAM（SRAM），动态RAM(DRAM)，ROM</br>
- 静态RAMA</br>
SRAM速度比DRAM快，价格也贵的多，可用作高速缓存，既可以用在CPU芯片上，也可以用在片下。结构上，用6个晶体管实现一个单元。功能上，拥有双稳态特性，每个位
可以一直保持下去。即使现在是不稳定状态，也能很快的变为一种稳定状态并保持。只要有电，就能保持下去。
- 动态RAM</br>
作为主存，以及图形系统的帧缓冲区。结构上，由一个电容和一个访问晶体管组成。功能上，对光电干扰十分敏感。被干扰后会在10~100毫秒内失去电荷，但所幸，
计算机时钟周期以纳秒为单位。这样就可以定期重写刷新内存的每一位。
- 传统DRAM</br>
数据存储在超单元中，一个超单元有8位。超单元被排列成矩阵形式。总共能存储行*列*8位数据。数据通过引脚进行读取写入，每个引脚传递1位信号。
为了一次能读出一个字节，数据引脚一般为8个一组，地址就是行列数，因此只需要2位。每个DRAM芯片要连接到内存控制器这样的电路上，通过这个电路读写数据。二维阵列
减少了地址引脚的个数，但增加了访问时间。因为先取行数据到缓冲区，再从缓冲区取列数据。
- 内存模块</br>
DRAM芯片封装在内存模块中，插到主板的扩展槽上。把数据传到内存控制器和从控制器中读出数据。结构上，8个DRAM芯片并联。每个超单元存8bit，一次使用64bits，每个DRAM
提供一个超单元，这些超单元地址相同，比如都是2行2列的那个超单元。
- 增强的DRAM</br>
双倍数据速率同步DRAM，也就是DDR SDRAM。首先SDRAM 是同步DRAM，与内存控制器用显示的控制信号进行同步，能够更快地输出超单元中的内容。而DDR是对SDRAM的
一种增强，使用两个时钟沿作为控制信号，是DRAM速度翻倍。根据缓冲区大小又有DDR,DDR2(4位),DDR3(8位)。
- 非易失性存储器</br>
断电的话，RAM会丢失他们的信息。ROM分为以下几类：</br>
  1. PROM 可编程ROM，只能被编一次，每个存储单元有一种熔丝，只能被高电流熔断一次。
  2. EPROM 可擦写可编程ROM,需要物理上的独立设备编程，通过紫外线擦除。
  3. flash 闪存，基于EEPROM。
存储在ROM中的程序被称作固件。当系统通电后会运行ROM中的固件。
- 访问主存
有了RAM以后，CPU又是如何与他们沟通的呢？</br>
CPU通过称为总线的共享电子电路与主存进行数据流通。每次数据传送都是通过一系列步骤完成的。这些步骤被称作
总线事物。读事务从主存到CPU，写事务从CPU到主存。</br>
总线又是如何与CPU，主存连接的呢？</br>
首先要有I/O桥接器，这是一个包含内存控制器的一个芯片组。他与CPU、主存、IO设备相连。与CPU的总线接口相连的那部分叫系统总线，与主存相连的叫内存总线，与IO设备相连的叫IO总线。</br>
CPU执行加载存储操作时会发生什么呢？</br>
加载：由总线接口发起读事务。拢共分三步：
  1. CPU将地址放到系统总线上。IO桥将信号传到内存总线上。
  2. 主存收到内存总线的地址，取出对应的数据字，放到内存总线上。IO桥将内存总线信号翻译为系统总线信号，系统总线信号沿系统总线传递。
  3. CPU接受系统总线上的数据字，复制到寄存器中。
存储：CPU发起写事务。拢共分三步：
  1. CPU将地址放到系统总线上，IO桥进行传递，主存读出地址，等待数据到来。
  2. CPU将寄存器中的数据复制到系统总线，IO桥传到内存总线上。
  3. 主存从内存总线上读出数据，并存储到DRAM中。

### 磁盘存储
首先磁盘是什么？</br>
磁盘用来保存大量数据，容量可以很大。但速度极慢。读取磁盘信息的时间是读DRAM的10万倍，是读SRAM的100万倍。
- 磁盘构造
构成：由多个盘片构成，盘片有上下两面，称为表面。表面上有磁性材料。表面由一组称为磁道的同心圆构成。磁道又被划分为一个个扇区，每个
扇区包含等量的数据位。扇区间由间隙隔开，间隙不存储数据位，存储表示扇区的格式化位。盘片中央有主轴，可以旋转。多个盘片在一个主轴上，
用柱面俩描述一个主轴上所有盘片到轴距离相等的磁道的集合。
- 磁盘操作
    读写头用来读写磁性表面的位，他连在传动臂上，传动臂可以沿着半径方向移动，这样就可以到达任意一个圆，也就是磁道上。读取时，传动臂移动到期望的磁道上，盘面开始旋转，当要读写的位经过读写头时，读写头能识别出这个位，然后进行读写。盘面旋转速度很快，如果盘面上有灰尘，会发生读写头冲撞。</br>
知道了怎么访问扇区后，来看一下对扇区的访问时间如何计算.主要分为寻到时间，旋转时间，传送时间。旋转时间与寻道时间基本相等，寻找第一个字节会很耗时，
但访问剩下的几乎不用时间
- 逻辑磁盘块
对操作系统而言，看到的是B个逻辑块，编号为0~B-1。擦盘封装中有有一个小的固件设备，维护实际的盘面，磁道，扇区三元组与逻辑编号的对应关系。这样，操作
系统只需要告诉他读取某个逻辑块号，磁盘就能通过这个控制器找到正确的位置。
- 连接I/O设备
鼠标键盘磁盘显卡这些东西如何与CPU,主存连在一起呢？</br>
这些IO设备通过IO总线连到IO桥上，通过桥与CPU,主存联系。系统总线，内存总线与CPU有关，而IO总线与CPU无关。Inter中以前是PCI总线，现在是PCIe总线。
IO总线比起系统总线，内存总线要慢很多，但可以连接不同种类的设备控制器，设备适配器。其中主机总线适配器用来连接磁盘，有两种协议：SCSI,STAT。SCSI
更贵更快，支持连接多个磁盘驱动器，STAT只能连一个磁盘驱动器。
- 访问磁盘
内存映射IO技术：IO设备被映射成一个或多个端口，CPU通过向这些端口发送命令来控制IO。
例如，CPU读磁盘：CPU向磁盘端口发送命令字，告诉磁盘要读，同时还有一些参数设置。再发送要读的逻辑块号。再发送储存结果的主存地址。磁盘在读出结果后，将
直接把结果传给主存，不再经过CPU，这样的技术叫做DMA。DMA完成后，会给CPU一个中断来纪律读取已完成。
 
 ### 固态硬盘
是基于闪存的存储技术，用芯片替代磁盘驱动器，读比写要快，因为只有一页中的所有位被擦除后才能写。在很多次重复写后会损坏。

## 局部性
局部性原理：程序往往倾向于引用最近使用过的数据附近的数据，或者最近引用的数据本身。分为时间局部性和空间局部性。时间局部性指的是一个内存位置在
不久的将来还会被多次使用。空间局部性指的是会使用已经使用的内存位置附近的内存位置。</br>
哪里用到了局部性原理呢？从硬件到程序都有应用。硬件方面，高速缓存存储器保存最近使用的指令和数据项；操作系统方面，使用主存作为最近被引用的虚拟地址块的缓存。应用方面，Web浏览器将最近使用的文档存储在本地磁盘上。

### 局部性原理
空间局部性是因为缓存数据是按块来传送的，一旦一个数据第一次不命中而被复制到缓存，他附近的数据也被复制过去了。时间局部性是因为这次复制进来后不会被擦除，紧接着用的话一定能命中。

### 对程序数据引用的局部性
循环体一直使用的变量有好的时间局部性。按照步长为1的引用模式引用的数组具有好的空间局部性。随着步长增加，空间局部性下降。二重循环中，注意idnex的顺序，
最好让列递增，这样就是步长为1的引用。如果每次是行递增，就是步长为N的引用。

### 取指令的局部性
程序指令存放在内存中，for循环体里的语句顺序执行，具有良好的空间局部性。同时循环会多次调用，也有时间局部性。循环体越小，迭代次数越多，局部性越好。

## 存储器层次结构
寄存器，L1高速缓存SRAM,L2高速缓存SRAM，L3高速缓存SRAM,主存DRAM,本地二级存储（机械磁盘，SSD），远程二级存储（分布式文件系统，web服务器）

### 各层次的缓存
位于k层的小块设备作为位于k+1层的大慢设备的缓存。k层存储着k+1层的一个子集。数据以块为大小进行传送。L0-L1 传送单元为1字，L1-L2-L3-L4几十个字
L4-L5几百几千字。
#### 缓存命中
程序需要k+1层中的某块，这块刚好在k层中缓存着，这就是缓存命中。
#### 缓存不命中
没有命中的话，就设计到替换的问题。被替换的这个快称作牺牲块，由缓存的替换策略决定替换哪个，一般是LRU算法，最近最少被使用的被替换。
#### 缓存不命中的种类
1. 强制性不命中：k层是空的
2. 冲突不命中：要请求的k+1层数据块被映射到k层的相同位置，比如请求0,8,0,8那么缓存中会是x,0,8,0这样每次都没有命中。
3. 容量不命中：缓存太小，容不下整个工作集。比如for要用10个块，而缓存只能放4个块。
#### 缓存管理
判断命中没有，层之间传送块都是缓存管理的工作内容。那么各层由谁来管理呢？寄存器由编译器管理，TLB由硬件MMU管理，L123由硬件管理，
虚拟内存由硬件和操作系统一起管理。

## 高速缓存存储器
最初只有CPU,DRAM,磁盘。后来由于CPU与主存间差距越来越大，只能在CPU寄存器与主存间插入一个SRAM高速缓存存储器。称为L1高速缓存。典型地，访问时间是
4个周期。后来又有了L2,L3.L2需要10个周期，L3需要50个周期。

### 通用的高速缓存存储器组织结构
首先一个存储器地址有m位，因此有2^m个地址，对这些地址进行哈希映射能够得到获得实际的存储位置。了解了地址线后，再来看一看
存储器内部的组织结构吧。内部被分为很多组，每个组又被分为很多行，每行可以理解为一个数组，里面有有效位，标记位，存储数据的高速缓存块。如何将地址与数据对应呢？也就是如何进行哈希呢？m位地址被划分为三部分
- 标记，t位，用来定位是第几行
- 组索引，s位，定位第几组
- 块偏移，b位，定位第几个字节
当收到内存总线上的地址后，拆解地址，判断是第几组第几行第几个数据，再返回给CPU</br>
问题又来了，怎么计算这个存储器的容量呢？
- 高速缓存块数目×行数×组数
高速缓存块数 B = 2^b，假如b=2，可以表示第1到第四字节，也就是每行有4字节高速缓存块。</br>
组数 S = 2^s，s位的索引可以表示2^s个组。行数E，不知道怎么确定的。。。。

### 直接映射高速缓存
根据行数把高速缓存分为不同类别。E = 1的叫直接映射高速缓存。接下来，来看一下当CPU执行读内存字w的指令时，会发生什么呢？</br>
命中就返回。不命中L1会向主存请求包含w的块，这段时间内，CPU必须等待，当这个块到达L1后。L1先将块存放到行里，再从块中抽取出w字，再返回给CPU。也就是分为三步：组选择，行匹配，字抽取
- 组选择
从地址中抽取索引位，解释为组的索引
- 行匹配
直接映射高速缓存只有每组只有一行，那么先判断这一行的有效位是否有效，再判断这一行的标记位是否与地址中的标记位一致。如果一致就说明缓存命中。
- 字选择
命中的话，就要进行字选择了。根据地址中的块偏移位，计算出偏移，如100就从块中的字节4开始。
- 若不命中，行替换
需要从下一层取出被请求的块。然后放到组索引指示的组中的某一行，直接映射高速只有一行，所以替换策略就是：用新取出的行替换当前的行。
- 运行中的直接映射高速缓存
每个组有多个块，在确定了组之后，根据标记位在不同的块中进行选择，在确定了块后，根据块偏移在一个块中选择指定字节。地址分为标记位，组索引，快偏移。存储器里面每一行分为有效位，标记位和块。标记位用来表示现在组里面存的是哪个块。因为不同块会被映射到同一组里，需要靠标记位来区分。地址被解析后与对应行的有效位，标记位对比，命中返回；不命中，替换。
- 直接cache中的冲突不命中
何时会发生冲突不命中呢？上一次使用的块与下一次要用的块映射到同一个组里，就会造成冲突不命中。解决办法也简单，修改下次要用的数据的地址，以此来更改
组索引位，让下次要用的块映射到别的组里面去。分析这类问题时，由块大小来推偏移位个数b，再由组数推组索引位数s。那么组索引就是块偏移前面的s位。
  - 抖动：高速缓存反复加载驱逐同样的块。例如访问顺序是x1,y1,x2,y2,x3,y3,x4,y4.x和y映射到同一组中，块大小为4\*x1.那么现象就是第一次把x1-x4加载进来，第二次访问y，由于y也被映射到这一组，就驱逐x1-x4，加载y1-y4.第三次访问x2，又要驱逐y加载x。反反复复，每次都不会命中。
  - 为什么用中间的位做索引
  设计良好的程序会很好地利用空间局部性，多访问内存连续的数据。因此最好将这些连续访问的数据映射到不同的组中，以减少冲突不命中。而内存空间地址是连续的，要在连续的地址中找出每次地址增加就会变化的那几位，中间位就满足要求。使用中间位分组，相邻内存就会被映射到不同组中。
  
### 组相连高速缓存
有多个组，每组有多行的高速缓存结构。一个组有多行就可以缓解直接映射中的冲突不命中。相邻访问的块的映射到同一组也不会抖动。
- 组选择
  与直接映射一样，根据地址的组索引位可以轻易选出组。
- 行匹配，字选择
  与组内的每一行的有效位和标记位进行匹配，如果匹配成功就命中。和直接映射一样，命中后根据块偏移进行字选择。
- 不命中怎么办
  有空行，加载到空行中。没有空行，进行替换。替换策略有LFU(按照使用频率排序),LRU(按照上次使用时间排序)。越远离CPU，一次不命中的开销就越大，因为请求时间越靠下越久。所以要使用好的替换策略。
  
### 全相联高速缓存
只有一个组的结构。全相连地址中没有组索引，地址只有标记位和块偏移。由于匹配各行是并行的，所以构件像全相连高速缓存这种结构是困难且昂贵的。
因此，他只适合做小的高速缓存，比如虚拟内存中的翻译备用缓冲器TLB，他缓存页表项。

### 有关写的问题
- 直写：写命中之后，立即将高速缓存块写回紧接着的第一层中。缺点就是每次写回都会引起总线流量。
- 写回：尽可能推迟更新，只有当替换算法要驱逐这个块时才写回低一层中。能显著减少总线流量。
- 写分配：不懂。。。。

## 高速缓存对性能的影响

|参数|正面影响|负面影响|  
|--|--|--|  
|高速缓存大小|大容量能提高命中率|大容量会增加命中时间|  
|块大小|提高命中率|会损害时间局部性比空间局部性好的程序的命中率，块越大，传送时间就越长。增加命中时间，不命中处罚|
|相联度|相联度高能降低抖动的可能性|增加命中时间，不命中处罚。一般高层选低相联度，低层选高相联度|
|写策略|写回减少传送数量，数量少了传送时间也小了||













